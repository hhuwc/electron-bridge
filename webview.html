<!-- webview.html - webview内部页面 -->
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Webview Sync Bridge</title>
</head>
<body>
    <h1>Webview 页面</h1>
    <button onclick="testSyncCall()">测试同步调用</button>
    <button onclick="testAsyncCall()">测试异步调用</button>
    <pre id="result"></pre>

    <script>
        // 同步调用Bridge方法，会阻塞线程直到结果返回
        function syncBridgeCall(method, params) {
            console.log(`开始同步调用: ${method}`);
            const startTime = Date.now();
            
            const xhr = new XMLHttpRequest();
            // 发起同步请求到自定义URL
            xhr.open('POST', 'mp-bridge://sync', false); // 关键: async: false 实现同步阻塞
            xhr.setRequestHeader('Content-Type', 'application/json');
            
            // 处理请求状态变化
            xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                    console.log('XHR状态:', xhr.status, xhr.statusText);
                    console.log('响应头:', xhr.getAllResponseHeaders());
                }
            };
            
            try {
                // 发送请求，此处会阻塞线程
                xhr.send(JSON.stringify({ method, params }));
                
                const endTime = Date.now();
                console.log(`同步调用完成，耗时: ${endTime - startTime}ms`);
                console.log('响应状态:', xhr.status);
                console.log('响应文本:', xhr.responseText);
                
                if (xhr.status === 200) {
                    // 解析响应结果
                    return JSON.parse(xhr.responseText);
                } else {
                    throw new Error(`请求失败: ${xhr.status} ${xhr.statusText}`);
                }
            } catch (error) {
                console.error('同步调用出错:', error);
                console.error('XHR状态:', xhr.status);
                console.error('XHR响应:', xhr.responseText);
                throw error;
            }
        }

        // 异步调用Bridge方法
        async function asyncBridgeCall(method, params) {
            console.log(`开始异步调用: ${method}`);
            const startTime = Date.now();
            
            try {
                const response = await fetch('mp-bridge://sync', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ method, params })
                });
                
                const endTime = Date.now();
                console.log(`异步调用完成，耗时: ${endTime - startTime}ms`);
                console.log('响应状态:', response.status);
                
                if (response.ok) {
                    const result = await response.json();
                    return result;
                } else {
                    throw new Error(`请求失败: ${response.status} ${response.statusText}`);
                }
            } catch (error) {
                console.error('异步调用出错:', error);
                throw error;
            }
        }

        // 测试同步调用的函数
        function testSyncCall() {
            const resultElement = document.getElementById('result');
            resultElement.textContent = '正在发起同步调用...（会阻塞线程）';
            
            try {
                // 测试1: 获取系统信息
                const sysInfo = syncBridgeCall('getSystemInfo', { detail: true });
                resultElement.textContent += '\n\n系统信息:\n' + JSON.stringify(sysInfo, null, 2);
                
                // 测试2: 执行加法计算
                const sumResult = syncBridgeCall('calculateSum', { a: 10, b: 20 });
                resultElement.textContent += '\n\n计算结果:\n' + JSON.stringify(sumResult, null, 2);
                
                // 测试3: 模拟耗时操作
                const slowResult = syncBridgeCall('slowOperation', { delay: 1000 });
                resultElement.textContent += '\n\n耗时操作结果:\n' + JSON.stringify(slowResult, null, 2);
            } catch (error) {
                resultElement.textContent += '\n\n调用出错: ' + error.message;
            }
        }

        // 测试异步调用的函数
        async function testAsyncCall() {
            const resultElement = document.getElementById('result');
            resultElement.textContent = '正在发起异步调用...（不会阻塞线程）';
            
            try {
                // 测试1: 获取系统信息
                const sysInfo = await asyncBridgeCall('getSystemInfo', { detail: true });
                resultElement.textContent += '\n\n系统信息:\n' + JSON.stringify(sysInfo, null, 2);
                
                // 测试2: 执行加法计算
                const sumResult = await asyncBridgeCall('calculateSum', { a: 15, b: 25 });
                resultElement.textContent += '\n\n计算结果:\n' + JSON.stringify(sumResult, null, 2);
                
                // 测试3: 模拟耗时操作
                const slowResult = await asyncBridgeCall('slowOperation', { delay: 500 });
                resultElement.textContent += '\n\n耗时操作结果:\n' + JSON.stringify(slowResult, null, 2);
            } catch (error) {
                resultElement.textContent += '\n\n调用出错: ' + error.message;
            }
        }
    </script>
</body>
</html>
